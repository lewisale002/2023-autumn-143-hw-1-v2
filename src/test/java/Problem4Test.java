/*
 * DO NOT MAKE ANY CHANGES UNLESS SPECIFIED OTHERWISE
 */

import Problem4.CompoundingResult;
import Problem4.MillionDollarMaker;
import org.junit.Rule;
import org.junit.Test;
import org.junit.rules.TestName;

import java.util.ArrayList;
import java.util.List;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertTrue;

public class Problem4Test {
    @Rule
    public TestName name = new TestName();  // https://stackoverflow.com/questions/17230413/get-the-name-of-currently-executing-test-method-in-before-in-junit
    final float ONE_MILLION = 1000000f;

    public static class TestCase {
        // what's the class visibility of the following variables?
        // Is it "public"?
        // Or "private"?
        // Or "protected"?
        // What's "protected" anyway?
        final float initDeposit;
        final float monthlyContribution;
        final int lengthInYear;
        final float interestRate;

        CompoundingResult expectedResult;

        public TestCase(float initDeposit, float monthlyContribution,
                        int lengthInYear, float interestRate,
                        float expectInvested, float expectAccumulated) {
            this.initDeposit = initDeposit;     // why do we need "this" here?
            this.monthlyContribution = monthlyContribution;
            this.lengthInYear = lengthInYear;
            this.interestRate = interestRate;
            expectedResult = new CompoundingResult(expectInvested, expectAccumulated);
        }

        @Override
        public String toString() {
            return "TestCase{" +
                    "initDeposit=" + initDeposit +
                    ", monthlyContribution=" + monthlyContribution +
                    ", lengthInYear=" + lengthInYear +
                    ", interestRate=" + interestRate +
                    ", expectedResult=" + expectedResult +
                    '}';
            // Generated by IntelliJ.
        }
    }

    private static void runTests(String testName, List<TestCase> testCases) {
        for (TestCase testCase : testCases) {
            CompoundingResult actual = MillionDollarMaker.calculate(testCase.initDeposit,
                    testCase.monthlyContribution,
                    testCase.lengthInYear,
                    testCase.interestRate
            );
            assertEquals("Test " + testName + ", case " + testCase, testCase.expectedResult, actual);
        }
    }

    @Test
    public void varyingYears() {
        List<TestCase> testCases = new ArrayList<TestCase>() {
            {
                add(new TestCase(100, 20, 1, 10,
                        340, 350));

                add(new TestCase(100, 20, 2, 10,
                        580, 625));

                add(new TestCase(100, 20, 5, 10,
                        1300, 1626.28f));   // what's the appendix f for?

                add(new TestCase(100, 20, 10, 10,
                        2500, 4084.36f));
            }
        };

        runTests(name.getMethodName(), testCases);
    }

    @Test
    public void negativeInputs() {
        List<TestCase> testCases = new ArrayList<TestCase>() {
            {
                add(new TestCase(-2, 20, 1, 10,
                        0, 0));

                add(new TestCase(100, -1, 1, 10,
                        0, 0));

                add(new TestCase(100, 20, -2, 10,
                        0, 0));

                add(new TestCase(100, 20, 1, -5,
                        340, 335));

                add(new TestCase(100, 20, 1, -150,
                        0, 0));

                add(new TestCase(100, 20, 1, 150,
                        0, 0));
            }
        };

        runTests(name.getMethodName(), testCases);
    }

    @Test
    public void varyingRate() {
        float initDeposit = 100;
        float monthlyContribution = 40;
        int lengthInYear = 10;
        float expectInvested = 4900;
        float[] expectAccumulated = {7909.34f, 13079.34f, 21835.94f};
        float[] interestRates = {10, 20, 30};

        assertEquals(expectAccumulated.length, interestRates.length);

        List<TestCase> testCases = new ArrayList<>();

        for (int i = 0; i < interestRates.length; i++) {
            testCases.add(new TestCase(initDeposit, monthlyContribution, lengthInYear, interestRates[i],
                    expectInvested, expectAccumulated[i]));

        }

        runTests(name.getMethodName(), testCases);
    }

    @Test
    public void varyingInitDeposit() {
        float interestRate = 20;
        float monthlyContribution = 500;
        int lengthInYear = 10;
        float[] expectInvested = {60100f, 61000f, 65000f};
        float[] expectAccumulated = {156371.27f, 161943.86f, 186710.77f};
        float[] initDeposits = {100, 1000, 5000};

        assertEquals(expectAccumulated.length, expectInvested.length);
        assertEquals(initDeposits.length, expectInvested.length);

        List<TestCase> testCases = new ArrayList<>();

        for (int i = 0; i < initDeposits.length; i++) {
            testCases.add(new TestCase(initDeposits[i], monthlyContribution, lengthInYear, interestRate,
                    expectInvested[i], expectAccumulated[i]));
        }

        runTests(name.getMethodName(), testCases);
    }

    @Test
    public void varyingMonthlyContribution() {
        float initDeposit = 1000;
        float interestRate = 20;
        int lengthInYear = 10;
        float[] expectInvested = {121000f, 241000f, 361000f};
        float[] expectAccumulated = {317695.92f, 629200.11f, 940704.29f};
        float[] monthlyContributions = {1000, 2000, 3000};

        assertEquals(expectAccumulated.length, expectInvested.length);
        assertEquals(monthlyContributions.length, expectInvested.length);

        List<TestCase> testCases = new ArrayList<>();

        for (int i = 0; i < monthlyContributions.length; i++) {
            testCases.add(new TestCase(initDeposit, monthlyContributions[i], lengthInYear, interestRate,
                    expectInvested[i], expectAccumulated[i]));
        }

        runTests(name.getMethodName(), testCases);
    }

    @Test
    public void waysToReachOneMillion() {
        List<TestCase> testCases = new ArrayList<TestCase>() {
            {
                add(new TestCase(7000, 4000, 10, 15,
                        487000, 1002897.38f));

                add(new TestCase(500, 500, 25, 15,
                        150500, 1293217.58f));

                add(new TestCase(500, 100, 35, 15,
                        42500, 1123991.95f));

                // average stock market return (see shorturl.at/aHJT6)
                add(new TestCase(1000, 300, 35, 10,
                        127000, 1003790.16f));

                add(new TestCase(12000, 200, 11, 50,
                        38400, 1448358.98f));

                add(new TestCase(4000000, 0, 100, 1,
                        4000000, 1081925.53f));

                add(new TestCase(1000000, 100000, 25, -12,
                        2500000, 1000000f));
            }
        };

        for (TestCase testCase : testCases) {
            CompoundingResult actual = MillionDollarMaker.calculate(testCase.initDeposit,
                    testCase.monthlyContribution,
                    testCase.lengthInYear,
                    testCase.interestRate
            );

            assertTrue(actual.getAccumulated() >= ONE_MILLION);
        }
    }
}

/*
    When I am able to start putting away money to save, I will be sure to invest some of it in an account that
    accumulates compound interest because of its incredible ability to grow. I know well the absurdity that
    exponential growth can be, so putting my money somewhere with a reasonably high compound interest rate will grow
    significantly over time. Another thing I've learned from compound interest growth is the value in saving money.
    Money saved now, means more money to spend later due to interest, and this is especially true with compound
    interest. On the flip side, I will also be very careful not to have money where I owe compound interest because
    of how quickly I could end up owing a lot of money. Compound interest can be a weapon or a curse and in the future
    I will be mindful of how I can get the most out of it and not end up on the wrong side of the equation.
 */
